- **Задача 1. Авторизация и Регистрация (дедлайн — 14 декабря 2023)**
  Реализовать HTTP-сервер банковской системы в соответствие с REST API
  Данные сохранять в базу данных
  Для каждой ошибки необходимо выбрать наиболее подходящий HTTP код.
  Архитектура
  Сценарии использования
  1. Регистрация (создание) пользователя (POST /api/users)
     - Клиент передает **логин (строка)** и **пароль (строка)**
     - Проверяем, что логин уникальный в рамках системы. Вернуть ошибку в случае существования пользователя с таким логином
     - Сохраняем в базу его **идентификатор (uuid)**, **имя** и **хеш пароля**
     - Клиенту возвращается JWT токен с **идентификатором** пользователя. Время жизни токена выставляем в рамках пары часов
  2. Получение токена входа (POST /api/tokens)
     - Клиент передает **логин (строка)** и **пароль (строка)**
     - В системе ищется пользователь с таким логином
     - Если пользователь не найден, возвращаем ошибку
     - Сравниваем пароль найденного пользователя с переданным клиентом. В случае неравенства вернуть ошибку
     - Клиенту возвращается JWT токен с **идентификатором** пользователя. Время жизни токена выставляем в рамках пары часов
  Также для сервера добавить **middleware** с обработкой **паник**
- **Задача 2. Создание и получение счетов (дедлайн — 11 декабря 2023)**
  В нашей банковской системе у пользователя может быть несколько счетов с **разным** названием, которые пользователь может **создавать** и **просматривать**
  Сценарии использования:
  1. Создание счета (POST /api/accounts)
     - Клиент передает
       - **Название** счета в теле запроса
       - JWT-токен в заголовке **Authorization**
     - Проверяем что у **пользователя** не существует **счета** с таким **названием**. Возвращаем ошибку, если счет существует
     - Сохраняем **счет пользователя** с **названием и идентификатором пользователя**
     - В ответе возвращаем **созданный** счет
  2. Получение счетов пользователя (GET /api/accounts)
     - Клиент jwt-токен в заголовке **Authorization** вместе с опциональными query параметрами (фильтр)
       - name — название счета
       - itemsPerPage — количество элементов
       - page —страница пагинации
     - Достаем из базы данных все счета **текущего пользователя**, удовлетворяющие фильтрам
       - name — фильтрует по вхождение строки (регистронезависимо) в название счета (ILIKE в sql). Если пустой, то фильтр не применяется
       - itemsPerPage — берет определенное количество элементов на странице (LIMIT в sql). Если пустой (0 или меньше 0), то берется значение 1
       - page — берет определенную страницу (OFFSET в sql). Если пустой (0 или меньше 0), то берется значение 1
     - В ответе возвращаем объект с полем items, в котором содержится список найденных счетов
  Доставать **идентификатор** пользователя из заголовка Authorization в отдельном **middleware**. В обработчик из middleware передаем идентификатор в **контексте**.
- **Задача 3. Пополнение и снятие денег с счета. Работа с транзакцией (дедлайн — 18 декабря 2023)**
  Реализовать следующие эндпоинты:
  - Пополнение счета POST /api/deposits
    - Передаем:
      - Токен авторизации в заголовке Authorization
      - Сумма (int)
    - Логика
      - Найти счет (FOR UPDATE — блокирует запись для других транзакций)
      - Положить на него сумму
      - Сохранить счет
    - Обернуть всю логику в транзакцию
